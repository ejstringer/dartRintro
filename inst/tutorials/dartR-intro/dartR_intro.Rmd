---
title: "dartR Introductory Tutorials" 
author: "The dartR Team"
date: | 
    ![](images/dartR7.png){width=6cm}
output:
  learnr::tutorial:
    progressive: false
    allow_skip: true
    theme: "cerulean"
    highlight: "tango"
    css: ./css/dartR_style.css
runtime: shiny_prerendered
description: "Introduction to dartR - using the Canberra grassland earless dragon as an example."
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)

#necessary to render tutorial correctly
library(learnr) 
library(htmltools)
#options(repos = BiocManager::repositories())
library(dartR.data)
library(dartR.base)
gl.set.verbosity(3)

library(dartRintro) # for tutorial data

```


## Introduction {data-progressive=FALSE} 

This is your hands on introduction to [dartR](https://github.com/green-striped-gecko/dartRverse?tab=readme-ov-file#dartrverse-). The worked examples and exercises in this tutorial correspond to the [[Intro to dartR ebook](http://dartr.biomatix.org/dartR)]{style="color:#ff0000;"}. There are also accompanying [AI podcast summaries](https://public.3.basecamp.com/p/Dp1F2egZGXY5siDf1MPFqyyg) for all the chapters, which you should definitely check out if you are more of an auditory learner.

If you can't see the left sidebar, you just need to make the tutorial panel wider.

### 

### R code box

Throughout this tutorial there will be interactive R scripts/consoles (like the one below). This is like a mini version of R running within this tutorial. But since we are already in R, you can also follow along in your own console and start writing your own code in the source panel. You could even try testing some of what you learn on your own data.

But first, try running the code below (press the button that says *run code*)

```{r ex, exercise=TRUE}
# Press the Run Code button to run this code
1+1
```

```{r ex-solution}
# This is an example of the interactive component 
#of this tutorial. 

# Try running some code and testing out the three buttons:
#  - Run Code, 
#  - Start Over, 
#  - and Solution

```

###

Did you notice the tick that is showing before the *R code box* heading after running the code?

### 

It is worth noting that each R code box is independent, so code you ran in one will not be recognised by another. Don't worry though, we have done some fancy coding in the background for you to continue along, keeping track of the tasks performed before hand. 

Any troubles or tribulations with coding in dartR, we have a great community that can be found on the [dartR google group](https://groups.google.com/g/dartr).

### 

Some of the exercises within this tutorial are specific to your working environment or Rstudio, these types of exercises will be surrounded by a green box, like the one below.

::: {.my-solution icon="false"}
It might be loading in data, or setting the working directory, or creating an R project.

They need to be run in your console.
:::

### 

While going through the worked examples your progress will be saved, if at any point you would like to refresh the tutorial and start over, the <small>[Start Over]{style="color:#a3a3a3; font-family:'Jaldi', sans-serif;"}</small> button is located at the very bottom of the left sidebar, below the tutorial content.

### 

One final note, don't forget that all aspects of the material are beneficial for learning. The ebook for being introduced to the theory and methods, the worked examples to gain experience in the application, and finally the exercises to apply everything you have learned.

Alright! Let's introduce you to the data we will be using throughout these worked examples in the Next Topic. After that head back to the ebook and get ready to start working through the worked examples and exercises back here when prompted.

<p>Good luck on your Pop Gen journey! üòÅ</p>

## The data

[<small>*Data modified for educational purposes*</small>]{style="color:grey"}

*Tympanocryptis lineata*, the Canberra grassland earless dragon, is endemic to Australian natural temperate grasslands (Smith et al. 1999; Scott and Keogh 2000; Melville et al. 2007; Hoehn et al. 2010; Robertson et al. 2010; Stevens et al. 2010). It is fittingly named the grassland earless dragon because of its lack of external ear openings and functional tympanum (Robertson et al. 2010). Canberra grassland earless dragons, hereafter also referred to as dragons, are a foraging species consuming a diet of predominantly ants and other invertebrates. They use a sit-and-wait approach to predate on their prey (McGrath et al. 2014). Their movement is typically no greater than 100 metres every six weeks, with localised home ranges between 925m2 and 4668m2 (Stevens et al. 2010; Hoehn et al. 2013; McGrath et al. 2014). There are only a few remaining fragmented populations found in and around Canberra (Stevens et al. 2010; Nelson and Cooper 2017).  

![](images/ged.png){.class height="450"}

Nationally it is classed as endangered under the Environmental Protection and Biodiversity Conservation Act 1999 (ACT Government 2017). Monitoring of this species in the ACT began in Northern Canberra in 2002 and Western Canberra in 2006. A rapid decline in capture numbers for both populations was detected somewhere between 2004 and 2006 (Dimond et al. 2012; Hoehn et al. 2013) and more generally across several sites in the Canberra region from 1995 to 2009. The dragons have continued to decline raising conservation concern.

Genetic samples have been collected since 2006 and now is a good time to assess the status of the remaining populations. Given the low number of individuals remaining in the wild, managements main concern is whether the dragons are losing genetic diversity. You have been tasked in providing the management team with an assessment of the genetic status of the species. 


```{r echo=FALSE}
#devtools::install_github("r-spatial/mapview")
#gl.map.interactive(tympo.gl)

library(leaflet)

m<-leaflet() %>% addCircles(lng = tympo.gl@other$latlon$lon,
                         lat = tympo.gl@other$latlon$lat,
                         color = c('red', 'blue','green', 'white', 'yellow')[as.numeric(tympo.gl@pop)]) %>% 
  addTiles(urlTemplate = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png')
 m 
```

The following worked examples will walk you through the process of analysing genetic data to be able to answer whether or not the genetic diversity is decreasing in this critically endangered small agamid lizard. 

To coincide with the *Introduction to dartR: A Practical Guide* ebook, the worked examples have been broken up into steps:

1. Getting setup in RStudio

2. Coding in R - individual metrics

3. Genetic data structure and input

4. Genetic data manipulation

5. Basic filtering

6. Simple visualisation


## Worked Ex 1-1: Getting organised
###

A good first step on any data analysis journey is to get a little organised. RStudio's projects are a great way to do that. Let's create a project for our grassland earless dragon analysis (we will use the same project for all the worked examples).

### Create RStudio project

You can create a project in six easy steps (see fig below):

  1. Navigate to the [File]{style="color:#a3a3a3; font-family:'Arial'"} tab at the top of RStudio and select [New Project...]{style="color:#a3a3a3; font-family:'Arial'"} 
  
  2. Select **New Directory**
  
  3. Then select [New Project]{style="color:#a3a3a3; font-family:'Arial'"} at the top of the list
  
  4. The next step is to name your project (i.e. folder name - how about *dartR_tympos*)
  
  5. Then choose a location on your computer where you want to save your project ([Browse...]{style="color:#a3a3a3; font-family:'Arial'"} for easy navigation)
  
  6. Finally, all you need to do is press **Create Project**
  
  
![](images/project.png){.class height="750"}

### Folder structure

The next way to get organised is to have a good folder system, this is the folder system I recommend. 

- code (r scripts)

- data (raw data - READ ONLY)

- figures (figures created)

- output (data created)

You might have additional folders but these are a good start.

you can run the below code to generate the folders 

```{r eval=FALSE}
lapply(c('code', 'data', 'figures', 'output'), dir.create)
```

### Organising scripts

A nice aspect of R scripts in RStudio is that there is a way to create sections when writing code, similar to Microsoft Word headings. First open a new file: [File | New File | R Script]{style="color:#a3a3a3; font-family:'Arial'"}  

To define a heading you use hash symbols (# = level 1 heading, ## = level 2 heading, etc...) followed by the heading name and then at least four dashes. 

Here is an example of what it would look like

```{r}
# Heading 1 ------------------

## heading 2 ----

### heading 3 ----
```

You can also use ctrl + Shift + R as a shortcut to define level 1 headings.

What is nice is that then if you click on the outline at the top-right of your R script (indicated by the red arrow in the figure below) it will show you the headings in your script and you can also use it to navigate to different parts of your code by clicking on the headings in the outline.

![](images/outline.png)

These are all just ways to help you keep organised. Apply them as you see fit. 

Now lets get into some actual coding!

## Worked Ex 2-1: Data types

The first step is to get an overview of our samples. To do this lets use the dragon's individual metrics data. But before jumping in, let's get a bit of an overview of how R works.

R works with objects, that is, with self-contained entities that have defined attributes. The advantage of objects is that when you use one in calculations, R knows what it is and how to handle it in the calculation.

When you create an object in R, attributes are assigned to it by default. The decision is made behind the scenes. 

### Scalars (contains a single value)

Let's define our first R object, we want to keep track of the species name we are working with. Fill in the species name (...) below and then check the class of your new R object by typing in `species` into the brackets (...). If you are unsure you can click the solutions tab

```{r extwo1, exercise=TRUE}
species <- '...'
species
class(...)
```

```{r extwo1-solution}
species <- 'Tympanocryptis lineata'
species
class(species)
```

Next, we want to define the year when we started collecting tissue samples. Fill in the code similar to above, but in R numbers do not need quotation marks ('').

```{r extwo2, exercise=TRUE}
year <- ...
year
class(...)
```

```{r extwo2-solution}
year <- 2006
year
class(year)
```

You should see that R has automatically assigned the species name as a character and the first sampling year as numeric. Let's keep track of one more piece of information that is recognised by R in a distinct way. Indicate below if the dragon is classed as endangered using either `TRUE` or `FALSE`. Then check the class of this new R object.

```{r extwo3, exercise=TRUE}
endangered <- ...
endangered
class(...)
```

```{r extwo3-solution}
endangered <- TRUE
endangered
class(endangered)
```

As you should be able to see, this is a logical variable. This is a key part of coding and will come up a lot when manipulating data.


### Vectors (containing ordered set of values of the same type)

Now let's define another type of R object, that can include more than a single value, to keep track of the first five dragons captured. We will need three vectors, the first containing their ids (AA1-AA5), second their age (J, J, SA, A, SA), and third their snout-vent-length in mm (36,33,38,66,45). We use `c()` to define vectors. Fill in the code below with the information provided for the five dragons. Don't forget to include quotations around anything that is not a number. 

When you assign values there is no output, so if you want to see the results of what you have created don't forget to put the name of your R object on a new line, like we have done below.


```{r extwo4, exercise=TRUE}
ids <- c(...)
age <- c(...)
svl <- c(...)
ids
age
svl
```

```{r extwo4-solution}
ids <- c('AA1', 'AA2', 'AA3', 'AA4', 'AA5')
age <- c('J', 'J', 'SA', 'A', 'SA')
svl <- c(36, 33, 38, 66, 45)
```

Vectors can be subset using square brackets `[]`. Let's first just look at our adult dragon's length. It is the fourth dragon in our vector list so we would place 4 within the brackets. We can even remove the adult in the same fashion, just by adding a minus symbol, -4. 

```{r extwo5, exercise=TRUE}
svl <- c(36, 33, 38, 66, 45)
svl[...]
```

```{r extwo5-solution}
svl <- c(36, 33, 38, 66, 45)
svl[4]
svl[-4]
```

Another useful coding convention is the colon `:`, we can use it to access the juvenile lengths, the first two dragons in our list. The colon is a way to easily create a sequential string of numbers. How about also trying to subset just the last three dragons as well, the non-juveniles. 

```{r extwo6, exercise=TRUE}
svl <- c(36, 33, 38, 66, 45)
svl[...:...] #Juveniles
svl[...:...] #adults and sub-adults
```

```{r extwo6-solution}
svl <- c(36, 33, 38, 66, 45)
svl[1:2] #Juveniles
svl[3:5] #adults and sub-adults
```

What about only sub-adults. For them we would need to define positions 3 and 5 using `c()` within the square brackets. Another way to access parts of a vector are using conditional statements. Conditional statements produce logical outputs. Let's try the *equals* (`==`) condition for sub-adults as well and see that it has the same result as defining our sub-adults using `c()`. 

```{r extwo7, exercise=TRUE}
age <- c('J', 'J', 'SA', 'A', 'SA')
svl <- c(36, 33, 38, 66, 45)
svl[...] # c()
svl[age == 'SA'] # conditional statement
```

```{r extwo7-solution}
svl[c(3,5)] # c() or -c()
svl[age == 'SA'] # conditional statement (or change !=)
```

The opposite to the *equals* condition is the *not equals* (`!=`), similar to adding the minus sign in front of `c()`. Why not give it a try by adjusting the code above, again expecting the same output for both `-c()` and `!=` statements. 

You should by now have the gist. A vector is a data structure that holds an ordered set of numbers, each of which can be addressed by its position in the ordered set, or by applying some logical condition, using square brackets.


### Factors

Factors are special types of vectors whose values have labels associated with them. For example, we might create a character vector containing a combined sex and maturity code for the first five dragons caught (J, J, M, M, F).

Converting a vector to a factor causes the values, in alphabetical order, to be assigned numbers, and those numbers to be assigned labels. 

A subtle difference to be sure. The numbers are hidden behind the scenes, and re-caste with their character values by R when they are printed out. That they are stored as numbers is evident when we print the object sexcode out without reference to its class using `unclass()`.

```{r extwo8, exercise=TRUE}
sexcode <- c(...)
sexcode <- factor(sexcode)
sexcode
unclass(sexcode)
```

```{r extwo8-solution}
sexcode <- c('J','J','M','M','F')
```

::: {.my-callout}

For a more detailed account of working with vectors in R, refer to the AI summary on vectors. 

:::


### Dataframes

Dataframes are a central plank of data structures in R. Data frames organize data in rows and columns, just like Excel spreadsheets. Each row typically represents one entity and each column typically represents an attribute for that entity.
Dataframes can have different data types in different columns. You might have names as text in one column, weights as numbers in another, and test results as TRUE/FALSE values in a third column.

Let's combine all the individual metrics for our five dragons into one dataframe. Let's also add a column to indicate that the dragons have been genotypes by defining a new scalar called `genotyped` as `TRUE` and including that in our dataframe.

```{r extwodf1, exercise=TRUE}
ids <- c('AA1', 'AA2', 'AA3', 'AA4', 'AA5')
age <- c('J', 'J', 'SA', 'A', 'SA')
svl <- c(36, 33, 38, 66, 45)
genotyped <- ...

metrics <- data.frame(ids, ..., ..., ...)
metrics
```

```{r extwodf1-solution}
genotyped <- TRUE
metrics <- data.frame(ids, age, svl, genotyped)

```

DataFrame columns can be accessed as vectors using the `$` operator.

Let's check the svl of our five individuals

```{r meta}
ids <- c('AA1', 'AA2', 'AA3', 'AA4', 'AA5')
age <- c('J', 'J', 'SA', 'A', 'SA')
svl <- c(36, 33, 38, 66, 45)
genotyped <- TRUE

metrics <- data.frame(ids, age, svl, genotyped)

```


```{r extwodf2, exercise=TRUE, exercise.setup = "meta"}
metrics$...

```

```{r extwodf2-solution}
metrics$svl
```

The object df$svl is a vector, and all the usual operators for vectors apply. For example let's calculate the svl in centimeters instead of millimeters by dividing (`/`) svl by 10.

```{r extwodf3, exercise=TRUE, exercise.setup = "meta"}

```

```{r extwodf3-solution}
metrics$svl/10
```

Let's now add it as a new column to our dataframe. The simplest way to add a new variable to an existing dataframe is to use assignment `<-` with a new column name not already in the dataframe.

```{r extwodf4, exercise=TRUE, exercise.setup = "meta"}
metrics$svlcm <- ...
metrics

```

```{r extwodf4-solution}
metrics$svlcm <- metrics$svl/10
metrics
```

The length of the vector needs to be the same as the number of rows in the dataframe.

::: {.my-callout}

For a more detailed account of working with dataframes in R, refer to the AI summary on dataframes. 

:::


### Matricies (two-dimensional array - all elements the same data type)

The next bit of information we want to record for our five dragons is some genetic data. A matrix is a good object type to store genetic data in, where the rows are the individuals and columns store the information for distinct genetic markers. Let's record information for three genetic markers. 

SNP1: A/A, A/G, A/G, A/A, A/A

SNP2: C/G, G/G, G/G, C/G, G/G

SNP3: T/G, T/T, G/G, NA, T/T

Each marker has five values for each of the five dragons except for SNP3 which has a missing value for dragon four, denoted with NA.

Let's first make an empty matrix. Fill in the correct number of rows and columns we will need for our matrix.

```{r extwo9, exercise=TRUE}
genotypes <- matrix(data = NA, nrow = ..., ncol = ...)
genotypes
```

```{r extwo9-solution}
genotypes <- matrix(data = NA, nrow = 5, ncol = 3)
genotypes
```

Let's now label the rows and columns to remind ourselves of what they are. We should label our rownames with the dragon ids and the columns with SNP1, SNP2, and SNP3.

```{r extwo10, exercise=TRUE}
genotypes <- matrix(data = NA, nrow = 5, ncol = 3)
ids <- c('AA1', 'AA2', 'AA3', 'AA4', 'AA5')
rownames(genotypes) <- ...
colnames(genotypes) <- ...
genotypes
```

```{r extwo10-solution}
genotypes <- matrix(data = NA, nrow = 5, ncol = 3)
ids <- c('AA1', 'AA2', 'AA3', 'AA4', 'AA5')
rownames(genotypes) <- ids
colnames(genotypes) <- c('SNP1', 'SNP2', 'SNP3')
genotypes
```

Now we want to add in the genetic information as listed above. We can do this by subseting to columns to input the information for each SNP separately. Accessing a matrix using `[]` is similar to accessing a vector but because the matrix is two dimensional to distinguish between rows and columns we separate them using a comma `[rows,columns]`. In R `NA`, when it signifies missing data, does not need quotations. 

```{r geno}
genotypes <- matrix(data = NA, nrow = 5, ncol = 3)
ids <- c('AA1', 'AA2', 'AA3', 'AA4', 'AA5')
rownames(genotypes) <- ids
colnames(genotypes) <- c('SNP1', 'SNP2', 'SNP3')

```


```{r extwo11, exercise=TRUE, exercise.setup = "geno"}
genotypes[,...] <- c(...) # SNP1
genotypes[,...] <- c(...) # SNP2
genotypes[,...] <- c(...) # SNP3
genotypes

```

```{r extwo11-solution}
genotypes[,1] <- c('A/A', 'A/G', 'A/G', 'A/A', 'A/A')
genotypes[,2] <- c('C/G', 'G/G', 'G/G', 'C/G', 'G/G')
genotypes[,3] <- c('T/G', 'T/T', 'G/G', NA, 'T/T')

```

We coded our genotypes using characters, but often times genetic data are coded numerically. You can learn all about that in chapter 3 of the [[Intro to dartR ebook](http://dartr.biomatix.org/dartR)]{style="color:#ff0000;"}.

::: {.my-callout}

For a more detailed account of working with matrices in R, refer to the AI summary on matrices and arrays. 

:::


### Lists

Now it is time to put all our data together. This is not a necessary step but learning about lists can be pretty handy. 

A list is R's most flexible data structure ‚Äì it is an object that itself can hold a set different types of objects (vectors, matrices, data frames, even other lists) all together. Unlike vectors, matrices, or data frames that require elements to be the same type or have the same structure, lists can contain completely different kinds of objects with completely different types of data.

The elements of a list are in a specific order and position, for easy reference. The elements can be named or un-named. Lists can contain other lists among their elements. The elements of a list do not have to be the same size.

Let's add all the information we have been collecting together and take a look at the output.


```{r list}

species <- 'Tympanocryptis lineata'
year <- 2006
endangered <- TRUE

ids <- c('AA1', 'AA2', 'AA3', 'AA4', 'AA5')
age <- c('J', 'J', 'SA', 'A', 'SA')
svl <- c(36, 33, 38, 66, 45)
genotyped <- TRUE

metrics <- data.frame(ids, age, svl, genotyped)

genotypes <- matrix(data = NA, nrow = 5, ncol = 3)
rownames(genotypes) <- ids
colnames(genotypes) <- c('SNP1', 'SNP2', 'SNP3')

genotypes[,1] <- c('A/A', 'A/G', 'A/G', 'A/A', 'A/A')
genotypes[,2] <- c('C/G', 'G/G', 'G/G', 'C/G', 'G/G')
genotypes[,3] <- c('T/G', 'T/T', 'G/G', NA, 'T/T')

```


```{r extwo12, exercise=TRUE, exercise.setup = "list"}
tympo_data <- list(species, year, endangered, 
                   metrics, 
                   genotypes)
tympo_data

```


This is an unnamed list, distinguishing each element by double square brackets with the position number of the element in the list `[[#]]`. We can create a named list by adding a name followed by `=` followed by our data within `list()` or by assigning names after creating the unnamed list using `names()`.


```{r extwo13, exercise=TRUE, exercise.setup = "list"}
tympo_data <- list(sp = species, 
                   yr = ..., 
                   endangered= ..., 
                   indmetrics = ..., 
                   genotypes = ...)
tympo_data
```

```{r extwo13-solution}
tympo_data <- list(sp = species, 
                   yr = year, 
                   endangered= endangered, 
                   indmetrics = metrics, 
                   genotypes = genotypes)
tympo_data
```

Now you should be able to see that each element is distinguished by `$element_name`. You can access elements in a named list similar to the way you access columns in a dataframe using `$`.

::: {.my-callout}

For a more detailed account of working with lists in R, refer to the AI summary on lists. 

:::

## Worked Ex 2-2: Save and tidy


### Saving files

Sometimes you want to save your data for use in another R session or in other software. 

To save our dataframe we can use `write.csv()` for our list we will have to save it as an R object, we can use `saveRDS()` for this.

::: { .my-solution}

You can copy and paste the below code into a new R script to save the data we have created.

```{r eval = FALSE}
species <- 'Tympanocryptis lineata'
year <- 2006
endangered <- TRUE

ids <- c('AA1', 'AA2', 'AA3', 'AA4', 'AA5')
age <- c('J', 'J', 'SA', 'A', 'SA')
svl <- c(36, 33, 38, 66, 45)
genotyped <- TRUE

metrics <- data.frame(ids, age, svl, genotyped)

genotypes <- matrix(data = NA, nrow = 5, ncol = 3)
rownames(genotypes) <- ids
colnames(genotypes) <- c('SNP1', 'SNP2', 'SNP3')

genotypes[,1] <- c('A/A', 'A/G', 'A/G', 'A/A', 'A/A')
genotypes[,2] <- c('C/G', 'G/G', 'G/G', 'C/G', 'G/G')
genotypes[,3] <- c('T/G', 'T/T', 'G/G', NA, 'T/T')

tympo_data <- list(species, year, endangered, 
                   metrics, 
                   genotypes)
# save list
saveRDS(tympo_data, './output/workedex2_list.rds')

# save metrics dataframe

write.csv(metrics, './output/metrics.csv')

```

:::

Because these are data created in R we would save them in the **output** folder. It is always good to keep the associated R script that creates the data. So, don't forget to save your new R script into your **code** folder. ctrl/cmd + S is the short cut to save a file or select File in the top left of your RStudio and navigate to Save or Save As...

### Tidying workspace

Since we have saved our list of data we probably won't need it again. So, let's remove it from our *Environmnet*. We can do this using `rm()`. 

::: { .my-solution}

Simply type the name into the brackets of the R object you want to delete.

```{r eval = FALSE}
rm(tympo_data)
```

:::

But maybe we want a complete fresh start. We can remove all data created during our R session by navigating to the *Environment* pane and clicking on the little broom icon üßπ. 


::: { .my-solution}

Select the broom icon, you will then be prompted with a pop up box, just select *yes* if you are sure you want a fresh start. 

:::

This removes everything from our environment making it out as if we have started a whole new R session. 


## Worked Ex 2-3: Inputing data

In the previous worked example we were doing a lot of data entry. This is very uncommon in R programming, usually you would already have data stored somewhere and you would simply input the data and then start manipulating and analysing it. So let's do that now. 

Data can come in many formats but one of the most common is as a csv (comma separated values) file. R has an easy way of reading these into your R session, `read.csv()`. Let's use it to read in the individual metrics file `Tympo_metadata.csv`. 

First we need to determine where the file is located locally. Because the metadata is stored as part of the dartR.data package we can get the file location using the following code:


```{r extwo14, exercise=TRUE}
system.file(package = 'dartRintro', 'extdata', 'Tympo_metadata.csv')

```

Now we just need to insert the file location into the `read.csv()` function and assign it a name. Then we can view it.

```{r extwo15, exercise=TRUE}
filelocation <- ...
metrics <- read.csv(...)
metrics
```

```{r extwo15-solution}
filelocation <- system.file(package = 'dartRintro', 'extdata', 'Tympo_metadata.csv')
metrics <- read.csv(filelocation)
metrics
```


If you want to save `metrics` you can do so by using `write.csv()`. But first we need to define where it will go. If you are working within your own console your R session should be pointing to the location of your R project (you would have created an R project during Ex 1-1.). But within this tutorial it is pointing to a temporary drive which can be pretty tricky to find. 


::: {.my-callout}

There are other functions for loading in different types of data you can check out in the AI summary. 

:::


## Worked Ex 2-3: Functions

You may have realized that most of the commands used in R are functions of one sort or another. Functions in R are not functions in the mathematical sense, but rather are the equivalent to subroutines or subprograms in other languages. 

A function is a discrete block of code that takes data, manipulates it and returns the results of those manipulations. For example, the function sort() can be used to re-order a data vector. Let's try it with svl we defined earlier, first view the data without sorting then with the sort function.


```{r extwo17, exercise=TRUE}
svl <- c(36, 33, 38, 66, 45)
...
sort(...)
```

```{r extwo17-solution}
svl <- c(36, 33, 38, 66, 45)
svl
sort(svl)
```

Functions are at the essence of coding and we will be introducing you to dartR specific functions in the chapters ahead. There is a lot more you can learn about functions, this is just the beginning.

::: {.my-solution}

If you want information about a function you can simply type the function name including empty round brackets with a question mark before it, `?sort()`.

:::

::: {.my-callout}

For a more detailed account of working with functions in R, refer to the AI summary on functions. 

:::


## Worked Ex 3-1: Load and save

It is time to start working in the dartRverse! Welcome!

Let's start with an overview of the data, for further details check out [The data]{style="color:#cc9900"} tab in the left sidebar. 

You have been tasked in providing the management team with an assessment of the genetic status of the species. Given the low number of individuals remaining in the wild, managements main concern is whether the dragons are losing genetic diversity. **But before we can get into a genetic assessment of the species, there are a number of important steps to go through before hand**.

### Working directory

A first step is to make sure you have set your working directory. If you are in a project the working directory should be the folder location of your project. 

::: {.my-solution icon="false"}
If you haven't already, create a project using the RStudio menu (File - New Project). Refer to Worked Ex 1-1 for details. Your project will become the default directory for files.

You can change the directory by using The RStudio menu (Session - Set Working Directory). Alternatively use `setwd()`
:::

### 

Once you have your working directory setup it is a good idea to open an R script file (File - New File - R Script or use shortcut keys ctrl/cmd + shift + N) to write your code, instead of straight to the console.

::: {.my-solution icon="false"}
Then you need to load in **dartRverse** using the `library()` function

```{r eval = FALSE}
library(dartRverse)
```

:::

### 

By loading in the **dartRverse** package it should automatically load in **dartR.base** and **dartR.data**. These are packages we need for this tutorial.

::: {.my-solution icon="false"}
Set the global verbosity level to 3 to provided detailed diagnostics, add `gl.set.verbosity(3)` to your R script.

:::

### Download raw data

Now to the Canberra grassland earless dragon genetic data. Let's start by downloading the SNP data and associated metadata and saving them in a folder called **data**. 

- *link to SNP file* or run code below. This is the set of SNP data for CGEDs, in 2-row format as would be supplied by [Diversity Arrays Technology Pty Ltd](https://www.diversityarrays.com).

```{r eval = FALSE}
write.csv(system.file("extdata",
                      "Report_DTym25-13579_10_moreOrders_SNP_1.csv",
                      package = "dartRintro"),
          './data/Report_DTym25-13579_10_moreOrders_SNP_1.csv')
```


- *link to metadata file* or run code below. Recall that the individual metadata comprise attributes assigned to each individual.

```{r eval = FALSE}
write.csv(system.file("extdata",
                      "Tympo_metadata.csv", 
                      package = "dartRintro"),
          './data/Tympo_metadata.csv')
```

### Read the data into dartR

::: {.my-solution icon="false"}
Read the data from [Report_DTym25-13579_10_moreOrders_SNP_1.csv]{style="color:blue; font-family: 'Courier New';"} into a dartR object and assign the individual metrics using `gl.read.dart()`

Name your dartR object `gl`

```{r, eval = FALSE}

snpfile <- "./data/Report_DTym25-13579_10_moreOrders_SNP_1.csv"
gl <- gl.read.dart(filename=snpfile,
                         ind.metafile="./data/Tympo_metadata.csv")
```

:::


This is the output you should see when reading in the data.

```{r, echo = FALSE}
gl <- gl.read.dart(filename=system.file("extdata", "Report_DTym25-13579_10_moreOrders_SNP_1.csv", package = "dartRintro"),
                   ind.metafile=system.file("extdata", "Tympo_metadata.csv", package = "dartRintro"))
```

Well done, you should have now successfully read in the dragons genetic data, ready to interrogate.

### Save as .rds

save


## Worked Ex 3-2: dartR object

Let's examine the contents of the Tympo dartR object.

### 

Just before we do, lets do a quick refresher of what a dartR object actually is, of course if you want more background check out the [ebook chapter](http://dartr.biomatix.org/dartR) associated with this tutorial.

### 

If you are familiar with genlight objects, a dartR object is effectively a version of a genlight object that is specific to the dartR package suite. A genlight object is a data structure used to efficiently store and analyse large genetic marker data. It includes the allelic state for each SNP called and for every individual genotyped.

### 

Additionally it also includes the metadata associated with the individuals genotyped and the SNP loci called. That's a lot of information! So lets learn how to interrogate our dartR object.

### Data overview

First let's confirm our `gl` is a dartR object using `class()`. Then to examine `gl` we simply need to run it on a new line and it will provide information about our data. 

```{r gl}
gl <- tympo.gl

```


```{r exthree1, exercise=TRUE, exercise.setup = "gl"}
class(...)
gl

```

```{r exthree1-solution}
class(gl)
gl
```

Another useful way to get an overview of our data is the basic report function,
`gl.report.basics()`. Within the function you can include the argument `verbose =` and set it as either 0, 1, 2, or 3, depending on the detail of output you want. Setting verbose to 0 will result in no output. 


```{r exthree2, exercise=TRUE, exercise.setup = "gl"}
gl.report.basics(...)

```

```{r exthree2-solution}
gl.report.basics(gl, verbose = 1)

```


## Worked Ex 3-3: Ind metrics

Let's get familar with some of the most important components to our data. First, we want to check how many individuals were genotyped and then how many per population. We can check the number of individuals with `nInd()` and the number of populations with `nPop()`.

```{r exthree3, exercise=TRUE, exercise.setup = "gl"}


```

```{r exthree3-solution}
nInd(gl)
nPop(gl)

```

That's interesting, if we look at the map under [The data]{style="color:#cc9900"} tab it shows only four populations. Let's check what the population names are using `popNames()` to try and figure out what is going on.

```{r exthree4, exercise=TRUE, exercise.setup = "gl"}


```

```{r exthree4-solution}
popNames(gl)

```


Ok, that makes more sense, we have a population called Unknown, so not an actual population. Let's check how many individuals are in this *unknown* population. we can do this using `pop()`, to list all the individuals populations, within `table()` that counts the number of values. You can check the output of `pop()` first if you are interested.

```{r exthree5a, exercise=TRUE, exercise.setup = "gl"}


```

```{r exthree5a-solution}
table(pop(gl))

```

Well that's good to know, it is just the one individual with an unknown population. Let's do a bit of fancy coding to figure out its id. we can use the function `indNames()` and square brackets with a conditional statement where `pop(gl) == 'Unknown'`. Give it ago below.

```{r exthree5, exercise=TRUE, exercise.setup = "gl"}


```

```{r exthree5-solution}
indNames(gl)[pop(gl) == 'Unknown']

```

Alright, not super informative, what about we get more information from the individual data about our unknown individual. 

dartR objects store individual metadata that can seem a little hard to access. But don't worry it's easier than it looks, all you need to know is the metadata's *address*. The individual metadata lives at `gl@other$ind.metrics`.

Let's first check the names of our columns in the metadata using `names()`. Another useful function for a quick overview of a dataframe is `head()` which shows you the column names and the first six entries. 

```{r exthree6, exercise=TRUE, exercise.setup = "gl"}


```

```{r exthree6-solution}
names(gl@other$ind.metrics)
head(gl@other$ind.metrics)

```

We have quite a lot of information for our dragons. Importantly we have latitudes and longitudes if we want to do any distance based analyses and we also have sex for detecting sex linkage, which will come later.   

Great now lets check the info about our unknown individual. We can use the same condition as we did before but now the square brackets come after the `gl@other$ind.metrics` and need a comma to distinguish between rows and columns, remember `[rows, column]`.

```{r exthree7, exercise=TRUE, exercise.setup = "gl"}


```

```{r exthree7-solution}
gl@other$ind.metrics[pop(gl) == 'Unknown',]

```

All we know is that it is a Canberra grassland earless dragon. 

Alright, I think it is time to check out some of the genetic data.

## Worked Ex 3-4: Loc metrics

Let's start by undertaking some basic diagnostics. First let's find out how many loci are in our dataset, using `nLoc()`.

```{r exthree8, exercise=TRUE, exercise.setup = "gl"}

```

```{r exthree8-solution}
nLoc(gl)
```

Ok well that seems like an low number of SNPs. I am more used to seeing SNPs in the tens of thousands, maybe someone has tampered with the data, or maybe forgot to provide the another data file with more SNPs. DArT usually sends two or even three files if there are more than 50,000 SNPs. Let's leave it for now and see what we can do with the SNPs we have.

To get a better understanding of how the SNP data is stored, first read chapter three of the ebook but then, we can us `as.matrix` to see the actual state of the SNPs for each individual. To make it a little easier to visualize lets look at a subset of individuals and SNPs, we use square brackets for this, `[individuals, SNPs]`.

Let's display the genotypes for the first 3 individuals and the first 6 loci. After running the below code, try showing the first 5 individuals and first 10 loci.

```{r exthree9, exercise=TRUE, exercise.setup = "gl"}
as.matrix(gl)[1:3,1:6]

```

```{r exthree9-solution}
as.matrix(gl)[1:5,1:10]

```

Well I am glad we could look at more individuals and loci, there is not much variation in the first three individuals and first six loci, they are either coded as 0, which indicates a homozygote for the reference allele, or NA for missing. 

When we look at more loci, we can see that loci ten has way more diversity, with homozygotes for both the reference (0) and alternative (2) alleles as well as a couple of homozygotes (1).

There seems to be a lot more missing data in the first five loci then the next five. We can actually check this by looking at the loc metrics.

The locus metadata included in the dartR object are those provided as part of your Diversity Arrays Technology report. These metadata are obtained from the Diversity Arrays Technology [csv]{style="color:blue; font-family: 'Courier New';"} file when it is read in to the genlight object using `gl.read.dart()`. The locus metadata are held in an R data.frame that is associated with the SNP data as part of the dartR object.

The loc metrics are similarly located as the ind metrics, `gl@other$loc.metrics`. Let's first look at the names of the loc metrics using `names()`.

```{r exthree10, exercise=TRUE, exercise.setup = "gl"}


```

```{r exthree10-solution}
names(gl@other$loc.metrics)

```

There is quite a bit of information in there. We are interested in the `CallRate` column for the first ten loci. We can access columns just like with any other dataframe using `$`. We can then use `[]` to subset the first 1:10 loci. If you want you could show the first 1:5 then 6:10.

```{r exthree11, exercise=TRUE, exercise.setup = "gl"}


```

```{r exthree11-solution}
gl@other$loc.metrics$CallRate[1:5]
gl@other$loc.metrics$CallRate[6:10]

```

Do you think the first loci have more missing data?

Instead of just looking at the first ten, why don't we do a histogram of all our loci's missing data rate, i.e., call rate. Instead of subsetting let's use the `hist()` on the `CallRate` instead.

```{r exthree12, exercise=TRUE, exercise.setup = "gl"}


```

```{r exthree12-solution}
hist(gl@other$loc.metrics$CallRate)

```

Great work! You really must be getting to know the data by now.

## Worked Ex 4-1: Manipulate



## Worked Ex 4-2: Report

## Worked Ex 4-3: History

## Worked Ex 5-1: Filtering

## Worked Ex 6-1: Visualise







