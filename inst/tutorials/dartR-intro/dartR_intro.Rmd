---
title: "Getting Started with dartR (ebook)" 
author: "The dartR Team"
date: | 
    ![](images/dartR7.png){width=6cm}
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
    theme: "cerulean"
    highlight: "tango"
    css: ./css/dartR_style.css
runtime: shiny_prerendered
description: "Introduction to dartR - using the Canberra grassland earless dragon as an example."
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE,
	collapse=TRUE
)

#necessary to render tutorial correctly
library(learnr) 
library(htmltools)
#options(repos = BiocManager::repositories())
library(dartR.data)
library(dartR.base)
library(dartR.sexlinked)
gl.set.verbosity(3)

library(dartRintro) # for tutorial data

```


## Introduction {data-progressive=FALSE} 

This is your hands on introduction to [dartR](https://github.com/green-striped-gecko/dartRverse?tab=readme-ov-file#dartrverse-). The worked examples and exercises in this tutorial correspond to the [[Intro to dartR ebook](http://dartr.biomatix.org/dartR)]{style="color:#ff0000;"}. There are also accompanying [AI podcast summaries](https://public.3.basecamp.com/p/Dp1F2egZGXY5siDf1MPFqyyg) for all the chapters, which you should definitely check out if you are more of an auditory learner.

If you can't see the left sidebar, you just need to make the tutorial panel wider.

### Google group

Any troubles or tribulations with coding in dartR, we have a great community that can be found on the [dartR google group](https://groups.google.com/g/dartr).

### Start Over

While going through the worked examples your progress will be saved, if at any point you would like to refresh the tutorial and start over, the <small>[Start Over]{style="color:#a3a3a3; font-family:'Jaldi', sans-serif;"}</small> button is located at the very bottom of the left sidebar, below the tutorial content.

### Worked examples and exercises

The first part of this tutorial are the worked examples, where we walk you through the process step by step. Following the worked examples you will get the chance to test your knowledge with the exercises, using real data to process datasets that have been used in scientific literature! 

###

One final note, don't forget that all aspects of the material are beneficial for learning. The ebook for being introduced to the theory and methods, the worked examples to gain experience in the application, and finally the exercises to apply everything you have learned.

### Let's get started!

Alright! Get started with your first worked example. After that head back to the ebook and get ready to start working through the worked examples and exercises back here when prompted.

<p>Good luck on your Pop Gen journey! üòÅ</p>


## Worked Ex 1-1: Getting organised
###

A good first step on any data analysis journey is to get a little organised. RStudio's projects are a great way to do that. Let's create a project for this ebook (you can use the same project for all the worked examples and exercises too!).

### Create RStudio project

You can create a project in six easy steps (see fig below):

  1. Navigate to the [File]{style="color:#a3a3a3; font-family:'Arial'"} tab at the top of RStudio and select [New Project...]{style="color:#a3a3a3; font-family:'Arial'"} 
  
  2. Select **New Directory**
  
  3. Then select [New Project]{style="color:#a3a3a3; font-family:'Arial'"} at the top of the list
  
  4. The next step is to name your project (i.e. folder name - how about *learning_dartR*)
  
  5. Then choose a location on your computer where you want to save your project ([Browse...]{style="color:#a3a3a3; font-family:'Arial'"} for easy navigation)
  
  6. Finally, all you need to do is press **Create Project**
  
  
![](images/project.png){.class height="750"}

### Folder structure

The next way to get organised is to have a good folder system, this is the folder system I recommend. 

- code (r scripts)

- data (raw data - READ ONLY)

- figures (figures created)

- output (data created)

###

You might have additional folders but these are a good start.

you can run the below code to generate the folders (run the code `getwd()` to double check they will be created where you want them) 

```{r eval=FALSE}
lapply(c('code', 'data', 'figures', 'output'), dir.create)
```

### Organising scripts

A nice aspect of R scripts in RStudio is that there is a way to create sections when writing code, similar to Microsoft Word headings. First open a new file: [File | New File | R Script]{style="color:#a3a3a3; font-family:'Arial'"}  

###

To define a heading you use hash symbols (# = level 1 heading, ## = level 2 heading, etc...) followed by the heading name and then at least four dashes. 

Here is an example of what it would look like

```{r}
# Heading 1 ------------------

## heading 2 ----

### heading 3 ----
```


You can also use ctrl + Shift + R as a shortcut to define level 1 headings.

###

A great feature is that by clicking the outline icon in the top-right corner of your R script (highlighted by the red arrow in the figure below), you can view all the headings in your script. This outline also allows you to quickly navigate to different sections of your code by selecting the corresponding headings.

![](images/outline.png)

###

These are all just ways to help you keep organised. Apply them as you see fit. 

Now lets get into some actual coding!

## Worked EX 2: Optional

Although we provide a chapter on R coding there are many R tutorials out there already. If you are new to R we recommend going through the [R Programming](https://github.com/swirldev/swirl_courses) course from the r package **swirl**. It teaches you R in your console. Here is the code to get started.

```{r eval=FALSE}
library(swirl)
install_course("R Programming")
swirl()
```

If you are familiar with R you can proceed to the next section. Let's get started! 

## Worked EX 3: data and map
### 
It is time to start working in the dartRverse! Welcome!

###

The worked examples will walk you through the process of preparing genetic data for analysis using the Canberra grassland earless dragon (Tympanocryptis lineata), a critically endangered species that is now found in a few remaining patches of lowland natural temperate grassland in the Australian Capital Territory. Refer to [ebook chapter 3](http://dartr.biomatix.org/dartR) for more details

###

Here is a map of the remaining populations.

```{r echo=FALSE}
#devtools::install_github("r-spatial/mapview")
#gl.map.interactive(tympo.gl)

library(leaflet)

m<-leaflet() %>% addCircles(lng = tympo.gl@other$latlon$lon,
                         lat = tympo.gl@other$latlon$lat,
                         color = c('red', 'blue','green', 'yellow')[as.numeric(tympo.gl@pop)]) %>% 
  addTiles(urlTemplate = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png')
 m 
```

[<small>*Data modified for educational purposes*</small>]{style="color:grey"}

###

It is worth noting that we have modified the data heavily for sake of illustration and they are provided for educational purposes only.

###

Great now it is time for some data processing

## Worked Ex 3-1: Load and save

###

Given the low number of individuals remaining in the wild, management's main concern is whether the dragons are losing genetic diversity. **But before we can get into a genetic assessment of the species, there are a number of important steps to go through before hand**.

### Working directory

A first step is to make sure you have set your working directory. If you are in a project the working directory should be the folder location of your project. Refer to worked Ex 1-1 on creating projects. Alternatively, you can use `setwd()`.

### Download raw data

Let's start by downloading the SNP data and associated metadata and saving them in your project folder, or better in a folder called **data**. 


- *link to SNP file*. This is the set of SNP data for CGEDs, in 2-row format as would be supplied by [Diversity Arrays Technology Pty Ltd](https://www.diversityarrays.com).


- *link to metadata file*. Recall that the individual metadata comprise attributes assigned to each individual.


### Read the data into dartR


Read the data from [Report_DTym25-13579_SNP_2.csv]{style="color:blue; font-family: 'Courier New';"} into a dartR object and assign the individual metrics using `gl.read.dart()`

```{r, eval = FALSE}
gl <- gl.read.dart("./data/Report_DTym25-13579_SNP_2.csv",
                   ind.metafile="./data/Tympo_metadata.csv")
```

###

```{r datainput, echo = FALSE, cache=TRUE}
gl <- gl.read.dart(filename=system.file("extdata", "Report_DTym25-13579_SNP_2.csv", package = "dartRintro"),
                   ind.metafile=system.file("extdata", "Tympo_metadata.csv", package = "dartRintro"))
```
###

This is the output you should see when reading in the data. It provides an overview of the steps taken during the import process. Pay particular attention to any messages about samples that could not be found in the metadata, as these will not be loaded. If this occurs, you may need to locate and add the missing metadata for those individuals to the `ind.metafile` file. 

###

We successfully read in the dragons genetic data, now it is ready to interrogate.

### Save 

Just before we do, it is good practice to save your data in binary format after the initial load. This ensures much faster access in future R sessions.

```{r eval=FALSE}
saveRDS(gl, 'tympo_genetic_data.rds')
```

###

You can also save it in a folder called **output** with the below code, assuming **output** is a folder in your working directory.

```{r eval=FALSE}
saveRDS(gl, './output/tympo_genetic_data.rds')
```

###

Make sure you name the data something descriptive and reasonable. 

###

Great all saved, let's move on!

## Worked Ex 3-2: dartR object
###

Let's examine the contents of the Tympo dartR object.

### 

Just before we do, lets do a quick refresher of what a dartR object actually is, of course if you want more background check out [ebook chapter](http://dartr.biomatix.org/dartR) 3.

### 

A *dartR* object is effectively a data structure used to efficiently store and analyse large genetic marker data. It includes the allelic state for each SNP called and for every individual genotyped.

### 

Additionally it also includes the metadata associated with the individuals genotyped and the SNP loci called. That's a lot of information! So lets learn how to interrogate our dartR object.

### Data overview

First let's confirm our `gl` is a dartR object using `class()`. 

```{r echo = FALSE}
gl <- tympo.gl

```


```{r eval=FALSE}
class(gl)

```

###

```{r echo = FALSE}
class(gl)

```

###

Great! It says it is a *dartR* object from the package **dartR.base**.

###

Now we can examine `gl`, we simply need to type its name

```{r eval=FALSE}
gl

```

###

```{r echo = FALSE}
gl
```

###

It provides us with a lot of useful information, the number of genotypes, which is referring to the number of individuals, and the number of SNPs. Just to name a few. 

###

Another useful way to get an overview of the data is the basic report function,
`gl.report.basics()`. Within the function you can include the argument `verbose =` and set it as either 0, 1, 2, or 3, depending on the detail of output you want. Let's try with verbose equal to 1.


```{r eval=FALSE}
gl.report.basics(gl, verbose = 1)

```

###

```{r exthree2, echo = FALSE}
gl.report.basics(gl, verbose = 1)

```

###
That is a lot of output, and verbose is only set to 1. Setting verbose to 0 will result in no output. Some useful bits of information are sample size as well as the percentage breakdown of 0s, 1s, 2s, and NAs in the data. Do you remember what these stand for?

###

If not refer back to the ebook. Otherwise let's keep moving.

## Worked Ex 3-3: Ind metrics
###

Let's get familar with some of the most important components to our data. We can use `nInd()` to remind ourselves of how many individuals are in the data.

```{r eval=FALSE}
nInd(gl)

```

###

```{r exthree3x, echo = FALSE}
nInd(gl)

```

###

Just as expected `r nInd(gl)` individuals.

###

The next important component is the number of populations, we can check this using `nPop()`.

```{r eval=FALSE}
nPop(gl)

```

###

```{r exthree3, echo = FALSE}
nPop(gl)

```

###

That's interesting, if we look at the map under the [data and map]{style="color:#cc9900"} tab it shows only four populations. 

###

Let's check what the population names are using `popNames()` to try and figure out what is going on.

```{r eval=FALSE}
popNames(gl)

```

###

```{r exthree4, echo = FALSE}
popNames(gl)

```

###

Ok, that makes more sense, we have a population called Unknown, so not an actual population. Let's check how many individuals are in this *unknown* population. 

###

We can check this using `pop()`, which lists each individuals' population, and then run it within `table()`, which counts the number of values. 

```{r  eval=FALSE}
table(pop(gl))

```

###

```{r exthree5a, echo = FALSE}
table(pop(gl))

```

###

Well that's good to know, it is just the one individual with an unknown population.

###

Let's do a bit of fancy coding to figure out its id. we can use the function `indNames()` and square brackets with a conditional statement where `pop(gl) == 'Unknown'`. 

```{r eval=FALSE}
indNames(gl)[pop(gl) == 'Unknown']

```

###

```{r exthree5, echo = FALSE}
indNames(gl)[pop(gl) == 'Unknown']

```

###

Alright, not super informative, what about we get more information from the individual data about our unknown individual.

###

dartR objects store individual metadata that can seem a little hard to access. But don't worry it's easier than it looks, all you need to know is the metadata's *address*. The individual metadata lives at `gl@other$ind.metrics`.

###

Let's first check the names of our columns in the metadata using `names()`. Another useful function for a quick overview of a dataframe is `head()` which shows you the column names and the first six entries. 

```{r eval=FALSE}
head(gl@other$ind.metrics)

```

###

```{r exthree6, echo = FALSE}
head(gl@other$ind.metrics)

```

###

We have quite a lot of information for our dragons. Importantly we have latitudes and longitudes if we want to do any distance based analyses and we also have sex for detecting sex linkage, which will come later.   

###

Great now lets check the info about our unknown individual. We can use the same condition as we did before but now the square brackets come after the `gl@other$ind.metrics` and need a comma to distinguish between rows and columns, remember `[rows, columns]`.

```{r eval=FALSE}
gl@other$ind.metrics[pop(gl) == 'Unknown',]

```

###

```{r exthree7, echo = FALSE}
gl@other$ind.metrics[pop(gl) == 'Unknown',]

```

###

All we know is that it is a Canberra grassland earless dragon...

###

Alright, I think it is time to check out some of the genetic data.

## Worked Ex 3-4: Loc metrics
###

Let's start by undertaking some basic diagnostics. First let's remind ourselves how many loci are in our dataset, using `nLoc()`.

```{r eval=FALSE}
nLoc(gl)
```

###

```{r exthree8, echo = FALSE}
nLoc(gl)
```

###

Ok well that seems like an low number of SNPs. I am used to seeing SNPs in the tens of thousands, maybe someone has tampered with the data, or maybe forgot to provide the other data file with more SNPs. DArT usually sends two or even three files if there are more than 50,000 SNPs. 

###

Whoops I forgot, these data have been modified for educational purposes. Just remember you should expect a lot more SNPs, which also means longer analysis times. Let's see what we can do with the SNPs we have.

###

To get a better understanding of how the SNP data are stored we can use `as.matrix()` to see the actual state of the SNPs for each individual. 

###

To make it a little easier to visualize lets look at a subset of individuals and SNPs, we use square brackets for this, `[individuals, SNPs]`. Let's display the genotypes for the first 20 individuals and the first 3 loci. 

```{r eval=FALSE}
as.matrix(gl)[1:20,1:3]

```

###

```{r exthree9, echo = FALSE}
as.matrix(gl)[1:20,1:3]

```

###

There is not much variation in the first two loci, they are either coded as 0, which indicates a homozygote for the reference allele, or NA for missing. Loci three has more diversity, with homozygotes for both the reference (0) and alternative (2) alleles as well as a few heterozygotes (1).

###

Each of the loci have missing data but we are only seeing the first 20 individuals, how much missing data are there for each of the loci? We can actually check this by looking at the loc metrics.

###

The locus metadata included in the dartR object are those provided as part of your Diversity Arrays Technology report and read in using `gl.read.dart()`. The locus metadata are held in an R dataframe that is associated with the SNPs as part of the dartR object.

###

The loc metrics are similarly located as the ind metrics, `gl@other$loc.metrics`. Let's first look at the names of the loc metrics using `names()`.

```{r eval=FALSE}
names(gl@other$loc.metrics)

```

###

```{r exthree10, echo = FALSE}
names(gl@other$loc.metrics)

```

###

There is quite a bit of information in there. We are interested in the first three loci's rate of missing data, i.e., call rate. Therefore, we are interested in the `CallRate` column. We can access columns just like with any other dataframe, using `$`. We can then use `[]` to subset the first 1:3 loci.

```{r eval=FALSE}
gl@other$loc.metrics$CallRate[1:3]

```

###

```{r exthree11, echo = FALSE}
gl@other$loc.metrics$CallRate[1:3]

```

###

Which locus has the most missing data?

###

Instead of just looking at the first three loci, why don't we do a histogram of all the loci's call rate. Instead of subsetting let's use `hist()` on the `CallRate` column instead.

```{r eval=FALSE}
hist(gl@other$loc.metrics$CallRate)

```

###

```{r exthree12, echo = FALSE}
hist(gl@other$loc.metrics$CallRate)

```

###

Most of the loci have a call rate close to 1! That means we should have a lot of high quality loci after filtering. 

###

You really must be getting to know the data by now. Let's move on to some data manipulations. 

